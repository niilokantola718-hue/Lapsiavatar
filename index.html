<!doctype html>
<html lang="fi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Lapsen perspektiivi VR ‚Äî 4-vuotias, realistinen parketti</title>
<style>
  html,body{height:100%;margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Arial}
  body{background:#000}
  #startBtn{
    position:absolute;top:16px;left:16px;z-index:100;
    padding:10px 16px;border-radius:8px;font-size:16px;border:0;
    color:#fff;background:linear-gradient(90deg,#4ECDC4,#FF6B6B);cursor:pointer;
  }
  #status{
    position:absolute;right:16px;top:16px;z-index:100;color:#fff;
    background:rgba(0,0,0,0.5);padding:8px 12px;border-radius:8px;font-size:14px;
  }
</style>
</head>
<body>
<button id="startBtn">K√§ynnist√§ VR</button>
<div id="status">Kameran korkeus lukittu: 0.95 m (4-vuotias)</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';
import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/webxr/VRButton.js';

// üîπ 4-vuotiaan silmien korkeus:
const LOCKED_Y = 0.95; 

let scene, camera, renderer, clock;
let statusEl = document.getElementById('status');

initScene();

function initScene(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xddeeff);

  camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.01, 100);
  camera.position.set(0, LOCKED_Y, 2.5);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(VRButton.createButton(renderer));

  const hemi = new THREE.HemisphereLight(0xffffff,0x777777,0.9);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xfff7e6,0.9);
  dir.position.set(4,8,4);
  dir.castShadow = true;
  dir.shadow.mapSize.set(1024,1024);
  scene.add(dir);

  createRoomWithParket();
  addDepthProps();

  window.addEventListener('resize', onWindowResize);
  clock = new THREE.Clock();
  renderer.setAnimationLoop(renderLoop);
}

function createRoomWithParket(){
  const loader = new THREE.TextureLoader();
  const colorURL = 'https://threejs.org/examples/textures/hardwood2_diffuse.jpg';
  const normalURL = 'https://threejs.org/examples/textures/hardwood2_normal.jpg';
  const roughURL = 'https://threejs.org/examples/textures/hardwood2_bump.jpg';

  const colorMap = loader.load(colorURL, tex=>{tex.wrapS=tex.wrapT=THREE.RepeatWrapping;tex.repeat.set(4,4);});
  const normalMap = loader.load(normalURL, tex=>{tex.wrapS=tex.wrapT=THREE.RepeatWrapping;tex.repeat.set(4,4);});
  const roughMap = loader.load(roughURL, tex=>{tex.wrapS=tex.wrapT=THREE.RepeatWrapping;tex.repeat.set(4,4);});

  const floorMat = new THREE.MeshStandardMaterial({
    map: colorMap,
    normalMap: normalMap,
    roughnessMap: roughMap,
    roughness: 0.7,
    metalness: 0.02
  });

  const floor = new THREE.Mesh(new THREE.PlaneGeometry(12,12,32,32), floorMat);
  floor.rotation.x = -Math.PI/2;
  floor.receiveShadow = true;
  floor.position.y = 0;
  scene.add(floor);

  const wallMat = new THREE.MeshStandardMaterial({color:0xf6f6f2,roughness:0.95});
  const wallBack = new THREE.Mesh(new THREE.PlaneGeometry(12,3), wallMat);
  wallBack.position.set(0,1.5,-6);
  scene.add(wallBack);
  const wallFront = wallBack.clone();
  wallFront.position.set(0,1.5,6);
  wallFront.rotation.y = Math.PI;
  scene.add(wallFront);
  const wallLeft = wallBack.clone();
  wallLeft.position.set(-6,1.5,0);
  wallLeft.rotation.y = Math.PI/2;
  scene.add(wallLeft);
  const wallRight = wallBack.clone();
  wallRight.position.set(6,1.5,0);
  wallRight.rotation.y = -Math.PI/2;
  scene.add(wallRight);
  const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(12,12), new THREE.MeshStandardMaterial({color:0xf8f8f8}));
  ceiling.rotation.x = Math.PI/2;
  ceiling.position.y = 3.0;
  scene.add(ceiling);
}

function addDepthProps(){
  const tableGeo = new THREE.BoxGeometry(0.6,0.35,0.5);
  const tableMat = new THREE.MeshStandardMaterial({color:0x8B5A2B,roughness:0.55});
  const table = new THREE.Mesh(tableGeo, tableMat);
  table.position.set(0,0.175,-1);
  table.castShadow=true;
  table.receiveShadow=true;
  scene.add(table);

  const sofa = new THREE.Mesh(new THREE.BoxGeometry(2,0.8,0.9),
    new THREE.MeshStandardMaterial({color:0x5b8aa8,roughness:0.7}));
  sofa.position.set(1.6,0.4,0.5);
  sofa.castShadow=true;
  scene.add(sofa);

  const toy1 = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.12,0.12),
    new THREE.MeshStandardMaterial({color:0xff4d4d}));
  toy1.position.set(-0.5,0.06,-0.5);
  scene.add(toy1);

  const toy2 = new THREE.Mesh(new THREE.SphereGeometry(0.08,12,12),
    new THREE.MeshStandardMaterial({color:0x00ff66}));
  toy2.position.set(0.6,0.08,0.2);
  scene.add(toy2);
}

function renderLoop(time, frame){
  if(renderer.xr.isPresenting){
    try{
      const xrCamera = renderer.xr.getCamera(camera);
      const pos = new THREE.Vector3().setFromMatrixPosition(xrCamera.matrixWorld);
      const quat = new THREE.Quaternion().setFromRotationMatrix(xrCamera.matrixWorld);
      camera.position.x = pos.x;
      camera.position.z = pos.z;
      camera.position.y = LOCKED_Y;
      camera.quaternion.copy(quat);
    }catch(e){console.warn('XR camera copy error',e);}
  }else{
    camera.position.y = LOCKED_Y;
    camera.lookAt(0, LOCKED_Y-0.25, 0);
  }
  renderer.render(scene,camera);
}

document.getElementById('startBtn').addEventListener('click', async ()=>{
  if(!navigator.xr){alert('WebXR ei k√§ytett√§viss√§.');return;}
  try{
    const session = await navigator.xr.requestSession('immersive-vr', {optionalFeatures:['local-floor','bounded-floor']});
    await renderer.xr.setSession(session);
    statusEl.textContent = `XR-istunto k√§ynniss√§ ‚Äî kamera lukittu y = ${LOCKED_Y.toFixed(2)} m`;
  }catch(err){
    console.error(err);
    alert('VR-istunnon k√§ynnistys ep√§onnistui: '+err.message);
  }
});

function onWindowResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
}
</script>
</body>
</html>
