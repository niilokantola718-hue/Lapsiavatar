<!DOCTYPE html>
<html lang="fi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Lapsi Avatar — VR/AR, dynaaminen lapsen perspektiivi</title>
<style>
  html,body { height:100%; margin:0; }
  body {
    background:#000;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    overflow:hidden;
  }
  #ui {
    position: absolute;
    inset: 0;
    display:flex;
    align-items:center;
    justify-content:center;
    z-index: 1000;
    background: rgba(0,0,0,0.7);
    flex-direction: column;
    gap: 12px;
  }
  button {
    padding: 12px 22px;
    font-size:16px;
    border-radius:10px;
    border: none;
    cursor:pointer;
    background: linear-gradient(135deg,#4ECDC4,#FF6B6B);
    color: white;
  }
  #status {
    color: #fff;
    max-width:80%;
    text-align:center;
    font-size:14px;
  }
  canvas { width:100%; height:100%; display:block; }
</style>
</head>
<body>
  <div id="ui">
    <button id="startButton">Käynnistä VR (lapsen perspektiivi)</button>
    <div id="status">Paina "Käynnistä VR" ja salli laitteesi VR-istunto.</div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
  // --- Asetukset ---
  const TARGET_EYE_HEIGHT = 0.9;   // haluttu lapsen silmien korkeus metreinä
  const WORLD_SCALE = 0.5;        // miten "iso" maailma tuntuu (0.5 = kaikki näyttää kahdesti suurelta)
  // --------------------

  let scene, camera, renderer;
  let world, avatar;
  let ui, statusEl, startBtn;

  ui = document.getElementById('ui');
  statusEl = document.getElementById('status');
  startBtn = document.getElementById('startButton');

  function setStatus(s){ statusEl.textContent = s; console.log(s); }

  function initScene(){
    scene = new THREE.Scene();

    // Kamera: asetetaan temporaalisesti lapsen silmien korkeudelle,
    // WebXR päivitää tämän sessiossa käyttäjän pose:lla.
    camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.01, 100);
    camera.position.set(0, TARGET_EYE_HEIGHT, 0);

    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    // Valot
    const amb = new THREE.AmbientLight(0xffffff, 0.9);
    scene.add(amb);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(0.5,1,0.5);
    scene.add(dir);

    // World: kaikki virtuaalinen sisältö lisätään tähän
    world = new THREE.Group();
    scene.add(world);
    world.scale.set(WORLD_SCALE, WORLD_SCALE, WORLD_SCALE);

    // Avatar ja huone
    createAvatar();
    createVirtualRoom();

    window.addEventListener('resize', onWindowResize);
  }

  function createAvatar(){
    avatar = new THREE.Group();
    // Pää
    const head = new THREE.Mesh(
      new THREE.SphereGeometry(0.15, 24, 24),
      new THREE.MeshPhongMaterial({ color: 0xFFD700, transparent:true, opacity:0.95 })
    );
    head.position.y = 0.15;
    avatar.add(head);
    // Vartalo
    const body = new THREE.Mesh(
      new THREE.CylinderGeometry(0.12, 0.15, 0.3, 24),
      new THREE.MeshPhongMaterial({ color: 0x4169E1, transparent:true, opacity:0.95 })
    );
    body.position.y = -0.15;
    avatar.add(body);

    avatar.position.set(0, -0.3, -0.5);
    world.add(avatar);
  }

  function createVirtualRoom(){
    // Lattia
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(6,6),
      new THREE.MeshPhongMaterial({ color: 0xe6e6e6 })
    );
    floor.rotation.x = -Math.PI/2;
    floor.position.y = 0;
    world.add(floor);

    // Seinät
    const wallMat = new THREE.MeshPhongMaterial({ color: 0xdddddd });
    const backWall = new THREE.Mesh(new THREE.PlaneGeometry(6,3), wallMat);
    backWall.position.set(0, 1.5, -3);
    world.add(backWall);

    const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(6,3), wallMat);
    leftWall.rotation.y = Math.PI/2; leftWall.position.set(-3,1.5,0);
    world.add(leftWall);

    const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(6,3), wallMat);
    rightWall.rotation.y = -Math.PI/2; rightWall.position.set(3,1.5,0);
    world.add(rightWall);

    const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(6,6), new THREE.MeshPhongMaterial({ color:0xf0f0f0 }));
    ceiling.rotation.x = Math.PI/2; ceiling.position.y = 3;
    world.add(ceiling);

    // Huonekalut lisävertailuksi (isommat, jotta tuntuu lapsen näkökulmalta)
    const table = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.12, 1.2), new THREE.MeshPhongMaterial({ color: 0x8B4513 }));
    table.position.set(0, 0.45, -1.2);
    world.add(table);

    const chair = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.0, 0.5), new THREE.MeshPhongMaterial({ color: 0x654321 }));
    chair.position.set(0.9, 0.5, -1.3);
    world.add(chair);

    const cabinet = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.5, 0.45), new THREE.MeshPhongMaterial({ color: 0x333333 }));
    cabinet.position.set(-1.2, 0.75, -1.6);
    world.add(cabinet);

    const lamp = new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,0.9,12), new THREE.MeshPhongMaterial({ color: 0xFFFFAA }));
    lamp.position.set(1.5, 0.45, -0.6);
    world.add(lamp);

    // Lattian referenssipisteet (auttavat liikkuessa)
    const markerGeo = new THREE.CircleGeometry(0.06, 16);
    const markerMat = new THREE.MeshBasicMaterial({ color: 0xff3333 });
    for(let x=-2;x<=2;x++){
      for(let z=-2;z<=2;z++){
        const m = new THREE.Mesh(markerGeo, markerMat);
        m.rotation.x = -Math.PI/2;
        m.position.set(x*0.8, 0.01, z*0.8 - 1.2);
        world.add(m);
      }
    }
  }

  function onWindowResize(){
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  // Apufunktio: hakee headsetin maailmankoordinaattien y:n
  function getHeadsetWorldPositionY() {
    // renderer.xr.getCamera() palauttaa kameraryhmän, matrixWorld sisältää headsetin transformin
    const xrCamera = renderer.xr.getCamera(camera);
    // Tämä ottaa keskimmäisen (stereo) kameraryhmän transformation
    const mat = xrCamera.matrixWorld;
    const pos = new THREE.Vector3();
    pos.setFromMatrixPosition(mat);
    return pos.y;
  }

  // Päärender
  function render(timestamp, frame) {
    // Kun XR-presenting, haetaan headsetin todellinen y ja kompensoidaan worldin y
    if (renderer.xr.isPresenting) {
      // Haetaan headsetin y (world-coords)
      let headsetY = getHeadsetWorldPositionY();
      // Lasketaan tarvittava siirto worldille niin, että headsetY + world.position.y = TARGET_EYE_HEIGHT
      // -> world.position.y = TARGET_EYE_HEIGHT - headsetY
      world.position.y = (TARGET_EYE_HEIGHT - headsetY);
      // Huom: pidämme world.x/z paikoillaan, jotta kävely toimii luonnollisesti.
    }

    // Pidä avatar "kehossasi"
    if (avatar && camera) {
      // kopioidaan headsetin orientaatio/paikka avatarille mutta pidetään se hieman alhaalla ja edessä
      const xrCam = renderer.xr.getCamera(camera);
      const camPos = new THREE.Vector3().setFromMatrixPosition(xrCam.matrixWorld);
      const camQuat = new THREE.Quaternion().setFromRotationMatrix(xrCam.matrixWorld);

      avatar.position.copy(camPos);
      avatar.position.y -= 0.3; // vartalon offset
      avatar.position.z -= 0.5; // hieman eteenpäin
      avatar.quaternion.copy(camQuat);
    }

    renderer.render(scene, camera);
  }

  // Käynnistetään immersive-vr ja asetetaan render-loop
  async function startVRSession() {
    if (!navigator.xr) {
      setStatus('WebXR ei tuettu tässä selaimessa.');
      return;
    }

    try {
      setStatus('Pyydetään immersive-vr -sessio...');
      const session = await navigator.xr.requestSession('immersive-vr', {
        optionalFeatures: ['local-floor', 'hand-tracking', 'layers']
      });

      await renderer.xr.setSession(session);
      ui.style.display = 'none';
      setStatus('VR käynnissä — kokemus on nyt lapsen perspektiivissä.');

      // kun sessio päättyy, palautetaan UI
      session.addEventListener('end', () => {
        ui.style.display = 'flex';
        setStatus('VR-sessio lopetettu.');
      });

      renderer.setAnimationLoop(render);

    } catch (err) {
      console.error('VR session error:', err);
      setStatus('VR-sessio epäonnistui: ' + (err && err.message ? err.message : String(err)));
    }
  }

  // INIT
  initScene();
  startBtn.addEventListener('click', startVRSession);
  </script>
</body>
</html>
